//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.2.2-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from F:\KU\Documents\Docxes_Txts_Pdfs\compilation\CppFuncDef\CppFuncDef\CppFuncDef.g4 by ANTLR 4.2.2-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace CppFuncDef {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.2.2-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class CppFuncDefParser : Parser {
	public const int
		WS=1, ANDTOKEN=2, ORTOKEN=3, EQUALTOKEN=4, LESSEQUAL=5, MOREEQUAL=6, NEGEQUAL=7, 
		ADDASSIGN=8, SUBASSIGN=9, MULASSIGN=10, DIVASSIGN=11, NEGTOKEN=12, PLUSTOKEN=13, 
		SUBTOKEN=14, DIVTOKEN=15, ASSIGNTOKEN=16, LESSTOKEN=17, MORETOKEN=18, 
		STAR=19, SEMICOLON=20, COMMA=21, ANDSINGLE=22, ORSINGLE=23, LEFTBRACKET=24, 
		RIGHTBRACKET=25, LEFTPAREN=26, RIGHTPAREN=27, CH=28, STR=29, WHILETOKEN=30, 
		FORTOKEN=31, RETURNTOKEN=32, VOIDTOKEN=33, BREAKTOKEN=34, CONTINUETOKEN=35, 
		DATATYPE=36, ID=37, CALLINGCONV=38, FIG=39, CONTIINUETOKEN=40;
	public static readonly string[] tokenNames = {
		"<INVALID>", "WS", "'&&'", "'||'", "'=='", "'<='", "'>='", "'!='", "'+='", 
		"'-='", "'*='", "'/='", "'!'", "'+'", "'-'", "'/'", "'='", "'<'", "'>'", 
		"'*'", "';'", "','", "'&'", "'|'", "'{'", "'}'", "'('", "')'", "CH", "STR", 
		"'while'", "'for'", "'return'", "'void'", "'break'", "'continue'", "DATATYPE", 
		"ID", "CALLINGCONV", "FIG", "CONTIINUETOKEN"
	};
	public const int
		RULE_cppFunction = 0, RULE_declarORassign = 1, RULE_expression = 2, RULE_whileStruct = 3, 
		RULE_forStruct = 4;
	public static readonly string[] ruleNames = {
		"cppFunction", "declarORassign", "expression", "whileStruct", "forStruct"
	};

	public override string GrammarFileName { get { return "CppFuncDef.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }


		protected const int EOF = Eof;

	public CppFuncDefParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class CppFunctionContext : ParserRuleContext {
		public ITerminalNode RETURNTOKEN(int i) {
			return GetToken(CppFuncDefParser.RETURNTOKEN, i);
		}
		public ITerminalNode SEMICOLON(int i) {
			return GetToken(CppFuncDefParser.SEMICOLON, i);
		}
		public ITerminalNode RIGHTBRACKET() { return GetToken(CppFuncDefParser.RIGHTBRACKET, 0); }
		public ForStructContext forStruct(int i) {
			return GetRuleContext<ForStructContext>(i);
		}
		public ITerminalNode[] DATATYPE() { return GetTokens(CppFuncDefParser.DATATYPE); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode[] STAR() { return GetTokens(CppFuncDefParser.STAR); }
		public ForStructContext[] forStruct() {
			return GetRuleContexts<ForStructContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public DeclarORassignContext declarORassign(int i) {
			return GetRuleContext<DeclarORassignContext>(i);
		}
		public ITerminalNode LEFTPAREN() { return GetToken(CppFuncDefParser.LEFTPAREN, 0); }
		public ITerminalNode STAR(int i) {
			return GetToken(CppFuncDefParser.STAR, i);
		}
		public DeclarORassignContext[] declarORassign() {
			return GetRuleContexts<DeclarORassignContext>();
		}
		public ITerminalNode ID(int i) {
			return GetToken(CppFuncDefParser.ID, i);
		}
		public WhileStructContext[] whileStruct() {
			return GetRuleContexts<WhileStructContext>();
		}
		public ITerminalNode[] SEMICOLON() { return GetTokens(CppFuncDefParser.SEMICOLON); }
		public ITerminalNode[] ID() { return GetTokens(CppFuncDefParser.ID); }
		public ITerminalNode COMMA(int i) {
			return GetToken(CppFuncDefParser.COMMA, i);
		}
		public ITerminalNode LEFTBRACKET() { return GetToken(CppFuncDefParser.LEFTBRACKET, 0); }
		public ITerminalNode RIGHTPAREN() { return GetToken(CppFuncDefParser.RIGHTPAREN, 0); }
		public WhileStructContext whileStruct(int i) {
			return GetRuleContext<WhileStructContext>(i);
		}
		public ITerminalNode[] RETURNTOKEN() { return GetTokens(CppFuncDefParser.RETURNTOKEN); }
		public ITerminalNode VOIDTOKEN() { return GetToken(CppFuncDefParser.VOIDTOKEN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(CppFuncDefParser.COMMA); }
		public ITerminalNode DATATYPE(int i) {
			return GetToken(CppFuncDefParser.DATATYPE, i);
		}
		public ITerminalNode CALLINGCONV() { return GetToken(CppFuncDefParser.CALLINGCONV, 0); }
		public CppFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_cppFunction; }
		public override void EnterRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.EnterCppFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.ExitCppFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICppFuncDefVisitor<TResult> typedVisitor = visitor as ICppFuncDefVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCppFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CppFunctionContext cppFunction() {
		CppFunctionContext _localctx = new CppFunctionContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_cppFunction);
		int _la;
		try {
			int _alt;
			State = 135;
			switch (_input.La(1)) {
			case DATATYPE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 10; Match(DATATYPE);
				State = 14;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==STAR) {
					{
					{
					State = 11; Match(STAR);
					}
					}
					State = 16;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 18;
				_la = _input.La(1);
				if (_la==CALLINGCONV) {
					{
					State = 17; Match(CALLINGCONV);
					}
				}

				State = 20; Match(ID);
				State = 21; Match(LEFTPAREN);
				State = 44;
				_la = _input.La(1);
				if (_la==DATATYPE) {
					{
					State = 22; Match(DATATYPE);
					State = 26;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==STAR) {
						{
						{
						State = 23; Match(STAR);
						}
						}
						State = 28;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 29; Match(ID);
					State = 41;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==COMMA) {
						{
						{
						State = 30; Match(COMMA);
						State = 31; Match(DATATYPE);
						State = 35;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==STAR) {
							{
							{
							State = 32; Match(STAR);
							}
							}
							State = 37;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 38; Match(ID);
						}
						}
						State = 43;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					}
				}

				State = 46; Match(RIGHTPAREN);
				State = 47; Match(LEFTBRACKET);
				State = 62;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
				while ( _alt!=2 && _alt!=ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						State = 60;
						switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
						case 1:
							{
							State = 48; declarORassign();
							State = 49; Match(SEMICOLON);
							}
							break;

						case 2:
							{
							State = 51; expression(0);
							State = 52; Match(SEMICOLON);
							}
							break;

						case 3:
							{
							State = 54; Match(RETURNTOKEN);
							State = 55; expression(0);
							State = 56; Match(SEMICOLON);
							}
							break;

						case 4:
							{
							State = 58; whileStruct();
							}
							break;

						case 5:
							{
							State = 59; forStruct();
							}
							break;
						}
						} 
					}
					State = 64;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
				}
				State = 65; Match(RETURNTOKEN);
				State = 66; expression(0);
				State = 67; Match(SEMICOLON);
				State = 82;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NEGTOKEN) | (1L << LEFTPAREN) | (1L << CH) | (1L << STR) | (1L << WHILETOKEN) | (1L << FORTOKEN) | (1L << RETURNTOKEN) | (1L << DATATYPE) | (1L << ID) | (1L << FIG))) != 0)) {
					{
					State = 80;
					switch ( Interpreter.AdaptivePredict(_input,8,_ctx) ) {
					case 1:
						{
						State = 68; declarORassign();
						State = 69; Match(SEMICOLON);
						}
						break;

					case 2:
						{
						State = 71; expression(0);
						State = 72; Match(SEMICOLON);
						}
						break;

					case 3:
						{
						State = 74; Match(RETURNTOKEN);
						State = 75; expression(0);
						State = 76; Match(SEMICOLON);
						}
						break;

					case 4:
						{
						State = 78; whileStruct();
						}
						break;

					case 5:
						{
						State = 79; forStruct();
						}
						break;
					}
					}
					State = 84;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 85; Match(RIGHTBRACKET);
				}
				break;
			case VOIDTOKEN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 87; Match(VOIDTOKEN);
				State = 89;
				_la = _input.La(1);
				if (_la==CALLINGCONV) {
					{
					State = 88; Match(CALLINGCONV);
					}
				}

				State = 91; Match(ID);
				State = 92; Match(LEFTPAREN);
				State = 115;
				_la = _input.La(1);
				if (_la==DATATYPE) {
					{
					State = 93; Match(DATATYPE);
					State = 97;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==STAR) {
						{
						{
						State = 94; Match(STAR);
						}
						}
						State = 99;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 100; Match(ID);
					State = 112;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==COMMA) {
						{
						{
						State = 101; Match(COMMA);
						State = 102; Match(DATATYPE);
						State = 106;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==STAR) {
							{
							{
							State = 103; Match(STAR);
							}
							}
							State = 108;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 109; Match(ID);
						}
						}
						State = 114;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					}
				}

				State = 117; Match(RIGHTPAREN);
				State = 118; Match(LEFTBRACKET);
				State = 131;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NEGTOKEN) | (1L << LEFTPAREN) | (1L << CH) | (1L << STR) | (1L << WHILETOKEN) | (1L << FORTOKEN) | (1L << RETURNTOKEN) | (1L << DATATYPE) | (1L << ID) | (1L << FIG))) != 0)) {
					{
					State = 129;
					switch ( Interpreter.AdaptivePredict(_input,15,_ctx) ) {
					case 1:
						{
						State = 119; declarORassign();
						State = 120; Match(SEMICOLON);
						}
						break;

					case 2:
						{
						State = 122; expression(0);
						State = 123; Match(SEMICOLON);
						}
						break;

					case 3:
						{
						State = 125; Match(RETURNTOKEN);
						State = 126; Match(SEMICOLON);
						}
						break;

					case 4:
						{
						State = 127; whileStruct();
						}
						break;

					case 5:
						{
						State = 128; forStruct();
						}
						break;
					}
					}
					State = 133;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 134; Match(RIGHTBRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarORassignContext : ParserRuleContext {
		public ITerminalNode DIVASSIGN() { return GetToken(CppFuncDefParser.DIVASSIGN, 0); }
		public ITerminalNode SUBASSIGN() { return GetToken(CppFuncDefParser.SUBASSIGN, 0); }
		public ITerminalNode ADDASSIGN() { return GetToken(CppFuncDefParser.ADDASSIGN, 0); }
		public ITerminalNode MULASSIGN() { return GetToken(CppFuncDefParser.MULASSIGN, 0); }
		public ITerminalNode ID() { return GetToken(CppFuncDefParser.ID, 0); }
		public ITerminalNode DATATYPE() { return GetToken(CppFuncDefParser.DATATYPE, 0); }
		public ITerminalNode ASSIGNTOKEN() { return GetToken(CppFuncDefParser.ASSIGNTOKEN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DeclarORassignContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_declarORassign; }
		public override void EnterRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.EnterDeclarORassign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.ExitDeclarORassign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICppFuncDefVisitor<TResult> typedVisitor = visitor as ICppFuncDefVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarORassign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarORassignContext declarORassign() {
		DeclarORassignContext _localctx = new DeclarORassignContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_declarORassign);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 148;
			switch ( Interpreter.AdaptivePredict(_input,20,_ctx) ) {
			case 1:
				{
				State = 138;
				_la = _input.La(1);
				if (_la==DATATYPE) {
					{
					State = 137; Match(DATATYPE);
					}
				}

				State = 140; Match(ID);
				State = 143;
				_la = _input.La(1);
				if (_la==ASSIGNTOKEN) {
					{
					State = 141; Match(ASSIGNTOKEN);
					State = 142; expression(0);
					}
				}

				}
				break;

			case 2:
				{
				State = 145; Match(ID);
				State = 146;
				_la = _input.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ADDASSIGN) | (1L << SUBASSIGN) | (1L << MULASSIGN) | (1L << DIVASSIGN))) != 0)) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 147; expression(0);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ITerminalNode ORSINGLE() { return GetToken(CppFuncDefParser.ORSINGLE, 0); }
		public ITerminalNode ORTOKEN() { return GetToken(CppFuncDefParser.ORTOKEN, 0); }
		public ITerminalNode NEGEQUAL() { return GetToken(CppFuncDefParser.NEGEQUAL, 0); }
		public ITerminalNode FIG() { return GetToken(CppFuncDefParser.FIG, 0); }
		public ITerminalNode ID() { return GetToken(CppFuncDefParser.ID, 0); }
		public ITerminalNode SUBTOKEN() { return GetToken(CppFuncDefParser.SUBTOKEN, 0); }
		public ITerminalNode MOREEQUAL() { return GetToken(CppFuncDefParser.MOREEQUAL, 0); }
		public ITerminalNode MORETOKEN() { return GetToken(CppFuncDefParser.MORETOKEN, 0); }
		public ITerminalNode STAR() { return GetToken(CppFuncDefParser.STAR, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode CH() { return GetToken(CppFuncDefParser.CH, 0); }
		public ITerminalNode LESSTOKEN() { return GetToken(CppFuncDefParser.LESSTOKEN, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RIGHTPAREN() { return GetToken(CppFuncDefParser.RIGHTPAREN, 0); }
		public ITerminalNode EQUALTOKEN() { return GetToken(CppFuncDefParser.EQUALTOKEN, 0); }
		public ITerminalNode STR() { return GetToken(CppFuncDefParser.STR, 0); }
		public ITerminalNode PLUSTOKEN() { return GetToken(CppFuncDefParser.PLUSTOKEN, 0); }
		public ITerminalNode LEFTPAREN() { return GetToken(CppFuncDefParser.LEFTPAREN, 0); }
		public ITerminalNode LESSEQUAL() { return GetToken(CppFuncDefParser.LESSEQUAL, 0); }
		public ITerminalNode ANDSINGLE() { return GetToken(CppFuncDefParser.ANDSINGLE, 0); }
		public ITerminalNode ANDTOKEN() { return GetToken(CppFuncDefParser.ANDTOKEN, 0); }
		public ITerminalNode DIVTOKEN() { return GetToken(CppFuncDefParser.DIVTOKEN, 0); }
		public ITerminalNode NEGTOKEN() { return GetToken(CppFuncDefParser.NEGTOKEN, 0); }
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_expression; }
		public override void EnterRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICppFuncDefVisitor<TResult> typedVisitor = visitor as ICppFuncDefVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 4;
		EnterRecursionRule(_localctx, 4, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 161;
			switch (_input.La(1)) {
			case NEGTOKEN:
				{
				State = 151; Match(NEGTOKEN);
				State = 152; expression(1);
				}
				break;
			case LEFTPAREN:
				{
				State = 153; Match(LEFTPAREN);
				State = 154; expression(0);
				State = 155; Match(RIGHTPAREN);
				}
				break;
			case ID:
				{
				State = 157; Match(ID);
				}
				break;
			case FIG:
				{
				State = 158; Match(FIG);
				}
				break;
			case CH:
				{
				State = 159; Match(CH);
				}
				break;
			case STR:
				{
				State = 160; Match(STR);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 174;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,23,_ctx);
			while ( _alt!=2 && _alt!=ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 172;
					switch ( Interpreter.AdaptivePredict(_input,22,_ctx) ) {
					case 1:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 163;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 164;
						_la = _input.La(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQUALTOKEN) | (1L << LESSEQUAL) | (1L << MOREEQUAL) | (1L << NEGEQUAL) | (1L << LESSTOKEN) | (1L << MORETOKEN))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 165; expression(10);
						}
						break;

					case 2:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 166;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 167;
						_la = _input.La(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << PLUSTOKEN) | (1L << SUBTOKEN) | (1L << DIVTOKEN) | (1L << STAR))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 168; expression(9);
						}
						break;

					case 3:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 169;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 170;
						_la = _input.La(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ANDTOKEN) | (1L << ORTOKEN) | (1L << ANDSINGLE) | (1L << ORSINGLE))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 171; expression(8);
						}
						break;
					}
					} 
				}
				State = 176;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,23,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class WhileStructContext : ParserRuleContext {
		public WhileStructContext[] whileStruct() {
			return GetRuleContexts<WhileStructContext>();
		}
		public ITerminalNode CONTINUETOKEN(int i) {
			return GetToken(CppFuncDefParser.CONTINUETOKEN, i);
		}
		public ITerminalNode[] SEMICOLON() { return GetTokens(CppFuncDefParser.SEMICOLON); }
		public ITerminalNode SEMICOLON(int i) {
			return GetToken(CppFuncDefParser.SEMICOLON, i);
		}
		public ITerminalNode RIGHTBRACKET() { return GetToken(CppFuncDefParser.RIGHTBRACKET, 0); }
		public ForStructContext forStruct(int i) {
			return GetRuleContext<ForStructContext>(i);
		}
		public ForStructContext[] forStruct() {
			return GetRuleContexts<ForStructContext>();
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode LEFTBRACKET() { return GetToken(CppFuncDefParser.LEFTBRACKET, 0); }
		public DeclarORassignContext declarORassign(int i) {
			return GetRuleContext<DeclarORassignContext>(i);
		}
		public ITerminalNode WHILETOKEN() { return GetToken(CppFuncDefParser.WHILETOKEN, 0); }
		public ITerminalNode RIGHTPAREN() { return GetToken(CppFuncDefParser.RIGHTPAREN, 0); }
		public WhileStructContext whileStruct(int i) {
			return GetRuleContext<WhileStructContext>(i);
		}
		public ITerminalNode[] CONTINUETOKEN() { return GetTokens(CppFuncDefParser.CONTINUETOKEN); }
		public ITerminalNode LEFTPAREN() { return GetToken(CppFuncDefParser.LEFTPAREN, 0); }
		public DeclarORassignContext[] declarORassign() {
			return GetRuleContexts<DeclarORassignContext>();
		}
		public ITerminalNode BREAKTOKEN(int i) {
			return GetToken(CppFuncDefParser.BREAKTOKEN, i);
		}
		public ITerminalNode[] BREAKTOKEN() { return GetTokens(CppFuncDefParser.BREAKTOKEN); }
		public WhileStructContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_whileStruct; }
		public override void EnterRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.EnterWhileStruct(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.ExitWhileStruct(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICppFuncDefVisitor<TResult> typedVisitor = visitor as ICppFuncDefVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStruct(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileStructContext whileStruct() {
		WhileStructContext _localctx = new WhileStructContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_whileStruct);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 177; Match(WHILETOKEN);
			State = 178; Match(LEFTPAREN);
			State = 179; expression(0);
			State = 180; Match(RIGHTPAREN);
			State = 181; Match(LEFTBRACKET);
			State = 196;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NEGTOKEN) | (1L << LEFTPAREN) | (1L << CH) | (1L << STR) | (1L << WHILETOKEN) | (1L << FORTOKEN) | (1L << BREAKTOKEN) | (1L << CONTINUETOKEN) | (1L << DATATYPE) | (1L << ID) | (1L << FIG))) != 0)) {
				{
				State = 194;
				switch ( Interpreter.AdaptivePredict(_input,24,_ctx) ) {
				case 1:
					{
					State = 182; declarORassign();
					State = 183; Match(SEMICOLON);
					}
					break;

				case 2:
					{
					State = 185; expression(0);
					State = 186; Match(SEMICOLON);
					}
					break;

				case 3:
					{
					State = 188; Match(BREAKTOKEN);
					State = 189; Match(SEMICOLON);
					}
					break;

				case 4:
					{
					State = 190; Match(CONTINUETOKEN);
					State = 191; Match(SEMICOLON);
					}
					break;

				case 5:
					{
					State = 192; whileStruct();
					}
					break;

				case 6:
					{
					State = 193; forStruct();
					}
					break;
				}
				}
				State = 198;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 199; Match(RIGHTBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForStructContext : ParserRuleContext {
		public WhileStructContext[] whileStruct() {
			return GetRuleContexts<WhileStructContext>();
		}
		public ITerminalNode[] SEMICOLON() { return GetTokens(CppFuncDefParser.SEMICOLON); }
		public ITerminalNode SEMICOLON(int i) {
			return GetToken(CppFuncDefParser.SEMICOLON, i);
		}
		public ITerminalNode CONTIINUETOKEN(int i) {
			return GetToken(CppFuncDefParser.CONTIINUETOKEN, i);
		}
		public ITerminalNode RIGHTBRACKET() { return GetToken(CppFuncDefParser.RIGHTBRACKET, 0); }
		public ForStructContext forStruct(int i) {
			return GetRuleContext<ForStructContext>(i);
		}
		public ForStructContext[] forStruct() {
			return GetRuleContexts<ForStructContext>();
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(CppFuncDefParser.COMMA, i);
		}
		public ITerminalNode FORTOKEN() { return GetToken(CppFuncDefParser.FORTOKEN, 0); }
		public ITerminalNode LEFTBRACKET() { return GetToken(CppFuncDefParser.LEFTBRACKET, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public DeclarORassignContext declarORassign(int i) {
			return GetRuleContext<DeclarORassignContext>(i);
		}
		public ITerminalNode RIGHTPAREN() { return GetToken(CppFuncDefParser.RIGHTPAREN, 0); }
		public WhileStructContext whileStruct(int i) {
			return GetRuleContext<WhileStructContext>(i);
		}
		public ITerminalNode[] CONTIINUETOKEN() { return GetTokens(CppFuncDefParser.CONTIINUETOKEN); }
		public ITerminalNode[] COMMA() { return GetTokens(CppFuncDefParser.COMMA); }
		public ITerminalNode LEFTPAREN() { return GetToken(CppFuncDefParser.LEFTPAREN, 0); }
		public DeclarORassignContext[] declarORassign() {
			return GetRuleContexts<DeclarORassignContext>();
		}
		public ITerminalNode BREAKTOKEN(int i) {
			return GetToken(CppFuncDefParser.BREAKTOKEN, i);
		}
		public ITerminalNode[] BREAKTOKEN() { return GetTokens(CppFuncDefParser.BREAKTOKEN); }
		public ForStructContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_forStruct; }
		public override void EnterRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.EnterForStruct(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICppFuncDefListener typedListener = listener as ICppFuncDefListener;
			if (typedListener != null) typedListener.ExitForStruct(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICppFuncDefVisitor<TResult> typedVisitor = visitor as ICppFuncDefVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForStruct(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForStructContext forStruct() {
		ForStructContext _localctx = new ForStructContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_forStruct);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201; Match(FORTOKEN);
			State = 202; Match(LEFTPAREN);
			State = 217;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NEGTOKEN) | (1L << LEFTPAREN) | (1L << CH) | (1L << STR) | (1L << DATATYPE) | (1L << ID) | (1L << FIG))) != 0)) {
				{
				State = 205;
				switch ( Interpreter.AdaptivePredict(_input,26,_ctx) ) {
				case 1:
					{
					State = 203; declarORassign();
					}
					break;

				case 2:
					{
					State = 204; expression(0);
					}
					break;
				}
				State = 214;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 207; Match(COMMA);
					State = 210;
					switch ( Interpreter.AdaptivePredict(_input,27,_ctx) ) {
					case 1:
						{
						State = 208; declarORassign();
						}
						break;

					case 2:
						{
						State = 209; expression(0);
						}
						break;
					}
					}
					}
					State = 216;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 219; Match(SEMICOLON);
			State = 228;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NEGTOKEN) | (1L << LEFTPAREN) | (1L << CH) | (1L << STR) | (1L << ID) | (1L << FIG))) != 0)) {
				{
				State = 220; expression(0);
				State = 225;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 221; Match(COMMA);
					State = 222; expression(0);
					}
					}
					State = 227;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 230; Match(SEMICOLON);
			State = 245;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NEGTOKEN) | (1L << LEFTPAREN) | (1L << CH) | (1L << STR) | (1L << DATATYPE) | (1L << ID) | (1L << FIG))) != 0)) {
				{
				State = 233;
				switch ( Interpreter.AdaptivePredict(_input,32,_ctx) ) {
				case 1:
					{
					State = 231; declarORassign();
					}
					break;

				case 2:
					{
					State = 232; expression(0);
					}
					break;
				}
				State = 242;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 235; Match(COMMA);
					State = 238;
					switch ( Interpreter.AdaptivePredict(_input,33,_ctx) ) {
					case 1:
						{
						State = 236; declarORassign();
						}
						break;

					case 2:
						{
						State = 237; expression(0);
						}
						break;
					}
					}
					}
					State = 244;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 247; Match(RIGHTPAREN);
			State = 248; Match(LEFTBRACKET);
			State = 263;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NEGTOKEN) | (1L << LEFTPAREN) | (1L << CH) | (1L << STR) | (1L << WHILETOKEN) | (1L << FORTOKEN) | (1L << BREAKTOKEN) | (1L << DATATYPE) | (1L << ID) | (1L << FIG) | (1L << CONTIINUETOKEN))) != 0)) {
				{
				State = 261;
				switch ( Interpreter.AdaptivePredict(_input,36,_ctx) ) {
				case 1:
					{
					State = 249; declarORassign();
					State = 250; Match(SEMICOLON);
					}
					break;

				case 2:
					{
					State = 252; expression(0);
					State = 253; Match(SEMICOLON);
					}
					break;

				case 3:
					{
					State = 255; Match(BREAKTOKEN);
					State = 256; Match(SEMICOLON);
					}
					break;

				case 4:
					{
					State = 257; Match(CONTIINUETOKEN);
					State = 258; Match(SEMICOLON);
					}
					break;

				case 5:
					{
					State = 259; whileStruct();
					}
					break;

				case 6:
					{
					State = 260; forStruct();
					}
					break;
				}
				}
				State = 265;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 266; Match(RIGHTBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 2: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 9);

		case 1: return Precpred(_ctx, 8);

		case 2: return Precpred(_ctx, 7);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3*\x10F\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x3\x2\x3\x2\a\x2\xF\n\x2"+
		"\f\x2\xE\x2\x12\v\x2\x3\x2\x5\x2\x15\n\x2\x3\x2\x3\x2\x3\x2\x3\x2\a\x2"+
		"\x1B\n\x2\f\x2\xE\x2\x1E\v\x2\x3\x2\x3\x2\x3\x2\x3\x2\a\x2$\n\x2\f\x2"+
		"\xE\x2\'\v\x2\x3\x2\a\x2*\n\x2\f\x2\xE\x2-\v\x2\x5\x2/\n\x2\x3\x2\x3\x2"+
		"\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3"+
		"\x2\a\x2?\n\x2\f\x2\xE\x2\x42\v\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2"+
		"\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\a\x2S\n\x2\f\x2"+
		"\xE\x2V\v\x2\x3\x2\x3\x2\x3\x2\x3\x2\x5\x2\\\n\x2\x3\x2\x3\x2\x3\x2\x3"+
		"\x2\a\x2\x62\n\x2\f\x2\xE\x2\x65\v\x2\x3\x2\x3\x2\x3\x2\x3\x2\a\x2k\n"+
		"\x2\f\x2\xE\x2n\v\x2\x3\x2\a\x2q\n\x2\f\x2\xE\x2t\v\x2\x5\x2v\n\x2\x3"+
		"\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2"+
		"\a\x2\x84\n\x2\f\x2\xE\x2\x87\v\x2\x3\x2\x5\x2\x8A\n\x2\x3\x3\x5\x3\x8D"+
		"\n\x3\x3\x3\x3\x3\x3\x3\x5\x3\x92\n\x3\x3\x3\x3\x3\x3\x3\x5\x3\x97\n\x3"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x5"+
		"\x4\xA4\n\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4"+
		"\xAF\n\x4\f\x4\xE\x4\xB2\v\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5"+
		"\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\a\x5\xC5"+
		"\n\x5\f\x5\xE\x5\xC8\v\x5\x3\x5\x3\x5\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6\xD0"+
		"\n\x6\x3\x6\x3\x6\x3\x6\x5\x6\xD5\n\x6\a\x6\xD7\n\x6\f\x6\xE\x6\xDA\v"+
		"\x6\x5\x6\xDC\n\x6\x3\x6\x3\x6\x3\x6\x3\x6\a\x6\xE2\n\x6\f\x6\xE\x6\xE5"+
		"\v\x6\x5\x6\xE7\n\x6\x3\x6\x3\x6\x3\x6\x5\x6\xEC\n\x6\x3\x6\x3\x6\x3\x6"+
		"\x5\x6\xF1\n\x6\a\x6\xF3\n\x6\f\x6\xE\x6\xF6\v\x6\x5\x6\xF8\n\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\a\x6\x108\n\x6\f\x6\xE\x6\x10B\v\x6\x3\x6\x3\x6\x3\x6\x2\x2"+
		"\x3\x6\a\x2\x2\x4\x2\x6\x2\b\x2\n\x2\x2\x6\x3\x2\n\r\x4\x2\x6\t\x13\x14"+
		"\x4\x2\xF\x11\x15\x15\x4\x2\x4\x5\x18\x19\x145\x2\x89\x3\x2\x2\x2\x4\x96"+
		"\x3\x2\x2\x2\x6\xA3\x3\x2\x2\x2\b\xB3\x3\x2\x2\x2\n\xCB\x3\x2\x2\x2\f"+
		"\x10\a&\x2\x2\r\xF\a\x15\x2\x2\xE\r\x3\x2\x2\x2\xF\x12\x3\x2\x2\x2\x10"+
		"\xE\x3\x2\x2\x2\x10\x11\x3\x2\x2\x2\x11\x14\x3\x2\x2\x2\x12\x10\x3\x2"+
		"\x2\x2\x13\x15\a(\x2\x2\x14\x13\x3\x2\x2\x2\x14\x15\x3\x2\x2\x2\x15\x16"+
		"\x3\x2\x2\x2\x16\x17\a\'\x2\x2\x17.\a\x1C\x2\x2\x18\x1C\a&\x2\x2\x19\x1B"+
		"\a\x15\x2\x2\x1A\x19\x3\x2\x2\x2\x1B\x1E\x3\x2\x2\x2\x1C\x1A\x3\x2\x2"+
		"\x2\x1C\x1D\x3\x2\x2\x2\x1D\x1F\x3\x2\x2\x2\x1E\x1C\x3\x2\x2\x2\x1F+\a"+
		"\'\x2\x2 !\a\x17\x2\x2!%\a&\x2\x2\"$\a\x15\x2\x2#\"\x3\x2\x2\x2$\'\x3"+
		"\x2\x2\x2%#\x3\x2\x2\x2%&\x3\x2\x2\x2&(\x3\x2\x2\x2\'%\x3\x2\x2\x2(*\a"+
		"\'\x2\x2) \x3\x2\x2\x2*-\x3\x2\x2\x2+)\x3\x2\x2\x2+,\x3\x2\x2\x2,/\x3"+
		"\x2\x2\x2-+\x3\x2\x2\x2.\x18\x3\x2\x2\x2./\x3\x2\x2\x2/\x30\x3\x2\x2\x2"+
		"\x30\x31\a\x1D\x2\x2\x31@\a\x1A\x2\x2\x32\x33\x5\x4\x3\x2\x33\x34\a\x16"+
		"\x2\x2\x34?\x3\x2\x2\x2\x35\x36\x5\x6\x4\x2\x36\x37\a\x16\x2\x2\x37?\x3"+
		"\x2\x2\x2\x38\x39\a\"\x2\x2\x39:\x5\x6\x4\x2:;\a\x16\x2\x2;?\x3\x2\x2"+
		"\x2<?\x5\b\x5\x2=?\x5\n\x6\x2>\x32\x3\x2\x2\x2>\x35\x3\x2\x2\x2>\x38\x3"+
		"\x2\x2\x2><\x3\x2\x2\x2>=\x3\x2\x2\x2?\x42\x3\x2\x2\x2@>\x3\x2\x2\x2@"+
		"\x41\x3\x2\x2\x2\x41\x43\x3\x2\x2\x2\x42@\x3\x2\x2\x2\x43\x44\a\"\x2\x2"+
		"\x44\x45\x5\x6\x4\x2\x45T\a\x16\x2\x2\x46G\x5\x4\x3\x2GH\a\x16\x2\x2H"+
		"S\x3\x2\x2\x2IJ\x5\x6\x4\x2JK\a\x16\x2\x2KS\x3\x2\x2\x2LM\a\"\x2\x2MN"+
		"\x5\x6\x4\x2NO\a\x16\x2\x2OS\x3\x2\x2\x2PS\x5\b\x5\x2QS\x5\n\x6\x2R\x46"+
		"\x3\x2\x2\x2RI\x3\x2\x2\x2RL\x3\x2\x2\x2RP\x3\x2\x2\x2RQ\x3\x2\x2\x2S"+
		"V\x3\x2\x2\x2TR\x3\x2\x2\x2TU\x3\x2\x2\x2UW\x3\x2\x2\x2VT\x3\x2\x2\x2"+
		"WX\a\x1B\x2\x2X\x8A\x3\x2\x2\x2Y[\a#\x2\x2Z\\\a(\x2\x2[Z\x3\x2\x2\x2["+
		"\\\x3\x2\x2\x2\\]\x3\x2\x2\x2]^\a\'\x2\x2^u\a\x1C\x2\x2_\x63\a&\x2\x2"+
		"`\x62\a\x15\x2\x2\x61`\x3\x2\x2\x2\x62\x65\x3\x2\x2\x2\x63\x61\x3\x2\x2"+
		"\x2\x63\x64\x3\x2\x2\x2\x64\x66\x3\x2\x2\x2\x65\x63\x3\x2\x2\x2\x66r\a"+
		"\'\x2\x2gh\a\x17\x2\x2hl\a&\x2\x2ik\a\x15\x2\x2ji\x3\x2\x2\x2kn\x3\x2"+
		"\x2\x2lj\x3\x2\x2\x2lm\x3\x2\x2\x2mo\x3\x2\x2\x2nl\x3\x2\x2\x2oq\a\'\x2"+
		"\x2pg\x3\x2\x2\x2qt\x3\x2\x2\x2rp\x3\x2\x2\x2rs\x3\x2\x2\x2sv\x3\x2\x2"+
		"\x2tr\x3\x2\x2\x2u_\x3\x2\x2\x2uv\x3\x2\x2\x2vw\x3\x2\x2\x2wx\a\x1D\x2"+
		"\x2x\x85\a\x1A\x2\x2yz\x5\x4\x3\x2z{\a\x16\x2\x2{\x84\x3\x2\x2\x2|}\x5"+
		"\x6\x4\x2}~\a\x16\x2\x2~\x84\x3\x2\x2\x2\x7F\x80\a\"\x2\x2\x80\x84\a\x16"+
		"\x2\x2\x81\x84\x5\b\x5\x2\x82\x84\x5\n\x6\x2\x83y\x3\x2\x2\x2\x83|\x3"+
		"\x2\x2\x2\x83\x7F\x3\x2\x2\x2\x83\x81\x3\x2\x2\x2\x83\x82\x3\x2\x2\x2"+
		"\x84\x87\x3\x2\x2\x2\x85\x83\x3\x2\x2\x2\x85\x86\x3\x2\x2\x2\x86\x88\x3"+
		"\x2\x2\x2\x87\x85\x3\x2\x2\x2\x88\x8A\a\x1B\x2\x2\x89\f\x3\x2\x2\x2\x89"+
		"Y\x3\x2\x2\x2\x8A\x3\x3\x2\x2\x2\x8B\x8D\a&\x2\x2\x8C\x8B\x3\x2\x2\x2"+
		"\x8C\x8D\x3\x2\x2\x2\x8D\x8E\x3\x2\x2\x2\x8E\x91\a\'\x2\x2\x8F\x90\a\x12"+
		"\x2\x2\x90\x92\x5\x6\x4\x2\x91\x8F\x3\x2\x2\x2\x91\x92\x3\x2\x2\x2\x92"+
		"\x97\x3\x2\x2\x2\x93\x94\a\'\x2\x2\x94\x95\t\x2\x2\x2\x95\x97\x5\x6\x4"+
		"\x2\x96\x8C\x3\x2\x2\x2\x96\x93\x3\x2\x2\x2\x97\x5\x3\x2\x2\x2\x98\x99"+
		"\b\x4\x1\x2\x99\x9A\a\xE\x2\x2\x9A\xA4\x5\x6\x4\x3\x9B\x9C\a\x1C\x2\x2"+
		"\x9C\x9D\x5\x6\x4\x2\x9D\x9E\a\x1D\x2\x2\x9E\xA4\x3\x2\x2\x2\x9F\xA4\a"+
		"\'\x2\x2\xA0\xA4\a)\x2\x2\xA1\xA4\a\x1E\x2\x2\xA2\xA4\a\x1F\x2\x2\xA3"+
		"\x98\x3\x2\x2\x2\xA3\x9B\x3\x2\x2\x2\xA3\x9F\x3\x2\x2\x2\xA3\xA0\x3\x2"+
		"\x2\x2\xA3\xA1\x3\x2\x2\x2\xA3\xA2\x3\x2\x2\x2\xA4\xB0\x3\x2\x2\x2\xA5"+
		"\xA6\f\v\x2\x2\xA6\xA7\t\x3\x2\x2\xA7\xAF\x5\x6\x4\f\xA8\xA9\f\n\x2\x2"+
		"\xA9\xAA\t\x4\x2\x2\xAA\xAF\x5\x6\x4\v\xAB\xAC\f\t\x2\x2\xAC\xAD\t\x5"+
		"\x2\x2\xAD\xAF\x5\x6\x4\n\xAE\xA5\x3\x2\x2\x2\xAE\xA8\x3\x2\x2\x2\xAE"+
		"\xAB\x3\x2\x2\x2\xAF\xB2\x3\x2\x2\x2\xB0\xAE\x3\x2\x2\x2\xB0\xB1\x3\x2"+
		"\x2\x2\xB1\a\x3\x2\x2\x2\xB2\xB0\x3\x2\x2\x2\xB3\xB4\a \x2\x2\xB4\xB5"+
		"\a\x1C\x2\x2\xB5\xB6\x5\x6\x4\x2\xB6\xB7\a\x1D\x2\x2\xB7\xC6\a\x1A\x2"+
		"\x2\xB8\xB9\x5\x4\x3\x2\xB9\xBA\a\x16\x2\x2\xBA\xC5\x3\x2\x2\x2\xBB\xBC"+
		"\x5\x6\x4\x2\xBC\xBD\a\x16\x2\x2\xBD\xC5\x3\x2\x2\x2\xBE\xBF\a$\x2\x2"+
		"\xBF\xC5\a\x16\x2\x2\xC0\xC1\a%\x2\x2\xC1\xC5\a\x16\x2\x2\xC2\xC5\x5\b"+
		"\x5\x2\xC3\xC5\x5\n\x6\x2\xC4\xB8\x3\x2\x2\x2\xC4\xBB\x3\x2\x2\x2\xC4"+
		"\xBE\x3\x2\x2\x2\xC4\xC0\x3\x2\x2\x2\xC4\xC2\x3\x2\x2\x2\xC4\xC3\x3\x2"+
		"\x2\x2\xC5\xC8\x3\x2\x2\x2\xC6\xC4\x3\x2\x2\x2\xC6\xC7\x3\x2\x2\x2\xC7"+
		"\xC9\x3\x2\x2\x2\xC8\xC6\x3\x2\x2\x2\xC9\xCA\a\x1B\x2\x2\xCA\t\x3\x2\x2"+
		"\x2\xCB\xCC\a!\x2\x2\xCC\xDB\a\x1C\x2\x2\xCD\xD0\x5\x4\x3\x2\xCE\xD0\x5"+
		"\x6\x4\x2\xCF\xCD\x3\x2\x2\x2\xCF\xCE\x3\x2\x2\x2\xD0\xD8\x3\x2\x2\x2"+
		"\xD1\xD4\a\x17\x2\x2\xD2\xD5\x5\x4\x3\x2\xD3\xD5\x5\x6\x4\x2\xD4\xD2\x3"+
		"\x2\x2\x2\xD4\xD3\x3\x2\x2\x2\xD5\xD7\x3\x2\x2\x2\xD6\xD1\x3\x2\x2\x2"+
		"\xD7\xDA\x3\x2\x2\x2\xD8\xD6\x3\x2\x2\x2\xD8\xD9\x3\x2\x2\x2\xD9\xDC\x3"+
		"\x2\x2\x2\xDA\xD8\x3\x2\x2\x2\xDB\xCF\x3\x2\x2\x2\xDB\xDC\x3\x2\x2\x2"+
		"\xDC\xDD\x3\x2\x2\x2\xDD\xE6\a\x16\x2\x2\xDE\xE3\x5\x6\x4\x2\xDF\xE0\a"+
		"\x17\x2\x2\xE0\xE2\x5\x6\x4\x2\xE1\xDF\x3\x2\x2\x2\xE2\xE5\x3\x2\x2\x2"+
		"\xE3\xE1\x3\x2\x2\x2\xE3\xE4\x3\x2\x2\x2\xE4\xE7\x3\x2\x2\x2\xE5\xE3\x3"+
		"\x2\x2\x2\xE6\xDE\x3\x2\x2\x2\xE6\xE7\x3\x2\x2\x2\xE7\xE8\x3\x2\x2\x2"+
		"\xE8\xF7\a\x16\x2\x2\xE9\xEC\x5\x4\x3\x2\xEA\xEC\x5\x6\x4\x2\xEB\xE9\x3"+
		"\x2\x2\x2\xEB\xEA\x3\x2\x2\x2\xEC\xF4\x3\x2\x2\x2\xED\xF0\a\x17\x2\x2"+
		"\xEE\xF1\x5\x4\x3\x2\xEF\xF1\x5\x6\x4\x2\xF0\xEE\x3\x2\x2\x2\xF0\xEF\x3"+
		"\x2\x2\x2\xF1\xF3\x3\x2\x2\x2\xF2\xED\x3\x2\x2\x2\xF3\xF6\x3\x2\x2\x2"+
		"\xF4\xF2\x3\x2\x2\x2\xF4\xF5\x3\x2\x2\x2\xF5\xF8\x3\x2\x2\x2\xF6\xF4\x3"+
		"\x2\x2\x2\xF7\xEB\x3\x2\x2\x2\xF7\xF8\x3\x2\x2\x2\xF8\xF9\x3\x2\x2\x2"+
		"\xF9\xFA\a\x1D\x2\x2\xFA\x109\a\x1A\x2\x2\xFB\xFC\x5\x4\x3\x2\xFC\xFD"+
		"\a\x16\x2\x2\xFD\x108\x3\x2\x2\x2\xFE\xFF\x5\x6\x4\x2\xFF\x100\a\x16\x2"+
		"\x2\x100\x108\x3\x2\x2\x2\x101\x102\a$\x2\x2\x102\x108\a\x16\x2\x2\x103"+
		"\x104\a*\x2\x2\x104\x108\a\x16\x2\x2\x105\x108\x5\b\x5\x2\x106\x108\x5"+
		"\n\x6\x2\x107\xFB\x3\x2\x2\x2\x107\xFE\x3\x2\x2\x2\x107\x101\x3\x2\x2"+
		"\x2\x107\x103\x3\x2\x2\x2\x107\x105\x3\x2\x2\x2\x107\x106\x3\x2\x2\x2"+
		"\x108\x10B\x3\x2\x2\x2\x109\x107\x3\x2\x2\x2\x109\x10A\x3\x2\x2\x2\x10A"+
		"\x10C\x3\x2\x2\x2\x10B\x109\x3\x2\x2\x2\x10C\x10D\a\x1B\x2\x2\x10D\v\x3"+
		"\x2\x2\x2(\x10\x14\x1C%+.>@RT[\x63lru\x83\x85\x89\x8C\x91\x96\xA3\xAE"+
		"\xB0\xC4\xC6\xCF\xD4\xD8\xDB\xE3\xE6\xEB\xF0\xF4\xF7\x107\x109";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace CppFuncDef
